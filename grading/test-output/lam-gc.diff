6,534c6,65
< \x.x
< \x.\y.x
< \x.\y.\z.((((x)@(z)))@(((y)@(z))))
< beta-reduce: ((((((\x.\y.\z.((((x)@(z)))@(((y)@(z)))))@(\x.\y.x)))@(\x.x)))@(\x.x)) =>
< ((((\y.\z.((((\x.\y.x)@(z)))@(((y)@(z)))))@(\x.x)))@(\x.x)) =>
< ((\z.((((\x.\y.x)@(z)))@(((\x.x)@(z)))))@(\x.x)) =>
< ((((\x.\y.x)@(\x.x)))@(((\x.x)@(\x.x)))) =>
< ((\y.\x.x)@(((\x.x)@(\x.x)))) =>
< \x.x
< beta-reduce: ((((\x.\y.x)@(\x.x)))@(\x.x)) =>
< ((\y.\x.x)@(\x.x)) =>
< \x.x
< Generating code for ((\x.x)@(\x.x))
< ------------------cut here------------------
< (*Generated by lam.cl (Jeff Foster, March 2000)*)
< class EvalObject inherits IO {
<   eval() : EvalObject { { abort(); self; } };
< };
< class Closure inherits EvalObject {
<   parent : Closure;
<   x : EvalObject;
<   get_parent() : Closure { parent };
<   get_x() : EvalObject { x };
<   init(p : Closure) : Closure {{ parent <- p; self; }};
<   apply(y : EvalObject) : EvalObject { { abort(); self; } };
< };
< class Main {
<   main() : EvalObject {
< (let x : EvalObject <- ((new Closure0).init(new Closure)),
<      y : EvalObject <- ((new Closure1).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac)
< };
< };
< class Closure1 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 1\n");
<       x <- y;
< get_x();}};
< };
< class Closure0 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 0\n");
<       x <- y;
< get_x();}};
< };
< ------------------cut here------------------
< Generating code for ((((((\x.\y.\z.((((x)@(z)))@(((y)@(z)))))@(\x.\y.x)))@(\x.x)))@(\x.x))
< ------------------cut here------------------
< (*Generated by lam.cl (Jeff Foster, March 2000)*)
< class EvalObject inherits IO {
<   eval() : EvalObject { { abort(); self; } };
< };
< class Closure inherits EvalObject {
<   parent : Closure;
<   x : EvalObject;
<   get_parent() : Closure { parent };
<   get_x() : EvalObject { x };
<   init(p : Closure) : Closure {{ parent <- p; self; }};
<   apply(y : EvalObject) : EvalObject { { abort(); self; } };
< };
< class Main {
<   main() : EvalObject {
< (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- ((new Closure0).init(new Closure)),
<      y : EvalObject <- ((new Closure1).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure2).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure3).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac)
< };
< };
< class Closure3 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 3\n");
<       x <- y;
< get_x();}};
< };
< class Closure2 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 2\n");
<       x <- y;
< get_x();}};
< };
< class Closure1 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 1\n");
<       x <- y;
< ((new Closure4).init(self));}};
< };
< class Closure4 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 4\n");
<       x <- y;
< get_parent().get_x();}};
< };
< class Closure0 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 0\n");
<       x <- y;
< ((new Closure5).init(self));}};
< };
< class Closure5 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 5\n");
<       x <- y;
< ((new Closure6).init(self));}};
< };
< class Closure6 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 6\n");
<       x <- y;
< (let x : EvalObject <- (let x : EvalObject <- get_parent().get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac);}};
< };
< ------------------cut here------------------
< Generating code for ((((((((((((((((\x.x)@(\x.\y.x)))@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))@(\x.\y.x)))@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))@(\x.x)))@(\x.\y.x)))@(\x.x))
< ------------------cut here------------------
< (*Generated by lam.cl (Jeff Foster, March 2000)*)
< class EvalObject inherits IO {
<   eval() : EvalObject { { abort(); self; } };
< };
< class Closure inherits EvalObject {
<   parent : Closure;
<   x : EvalObject;
<   get_parent() : Closure { parent };
<   get_x() : EvalObject { x };
<   init(p : Closure) : Closure {{ parent <- p; self; }};
<   apply(y : EvalObject) : EvalObject { { abort(); self; } };
< };
< class Main {
<   main() : EvalObject {
< (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- ((new Closure0).init(new Closure)),
<      y : EvalObject <- ((new Closure1).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure2).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure3).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure4).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure5).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure6).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure7).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- ((new Closure8).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac)
< };
< };
< class Closure8 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 8\n");
<       x <- y;
< get_x();}};
< };
< class Closure7 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 7\n");
<       x <- y;
< ((new Closure9).init(self));}};
< };
< class Closure9 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 9\n");
<       x <- y;
< get_parent().get_x();}};
< };
< class Closure6 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 6\n");
<       x <- y;
< get_x();}};
< };
< class Closure5 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 5\n");
<       x <- y;
< ((new Closure10).init(self));}};
< };
< class Closure10 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 10\n");
<       x <- y;
< ((new Closure11).init(self));}};
< };
< class Closure11 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 11\n");
<       x <- y;
< (let x : EvalObject <- (let x : EvalObject <- get_parent().get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac);}};
< };
< class Closure4 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 4\n");
<       x <- y;
< ((new Closure12).init(self));}};
< };
< class Closure12 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 12\n");
<       x <- y;
< get_parent().get_x();}};
< };
< class Closure3 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 3\n");
<       x <- y;
< ((new Closure13).init(self));}};
< };
< class Closure13 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 13\n");
<       x <- y;
< ((new Closure14).init(self));}};
< };
< class Closure14 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 14\n");
<       x <- y;
< (let x : EvalObject <- (let x : EvalObject <- get_parent().get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac);}};
< };
< class Closure2 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 2\n");
<       x <- y;
< ((new Closure15).init(self));}};
< };
< class Closure15 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 15\n");
<       x <- y;
< ((new Closure16).init(self));}};
< };
< class Closure16 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 16\n");
<       x <- y;
< (let x : EvalObject <- (let x : EvalObject <- get_parent().get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac);}};
< };
< class Closure1 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 1\n");
<       x <- y;
< ((new Closure17).init(self));}};
< };
< class Closure17 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 17\n");
<       x <- y;
< get_parent().get_x();}};
< };
< class Closure0 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 0\n");
<       x <- y;
< get_x();}};
< };
< ------------------cut here------------------
< Generating code for ((((\x.x)@(((\x.\y.x)@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))))@(((\x.\y.x)@(((\x.\y.\z.((((x)@(z)))@(((y)@(z)))))@(\x.\y.\z.((((x)@(z)))@(((y)@(z))))))))))
< ------------------cut here------------------
< (*Generated by lam.cl (Jeff Foster, March 2000)*)
< class EvalObject inherits IO {
<   eval() : EvalObject { { abort(); self; } };
< };
< class Closure inherits EvalObject {
<   parent : Closure;
<   x : EvalObject;
<   get_parent() : Closure { parent };
<   get_x() : EvalObject { x };
<   init(p : Closure) : Closure {{ parent <- p; self; }};
<   apply(y : EvalObject) : EvalObject { { abort(); self; } };
< };
< class Main {
<   main() : EvalObject {
< (let x : EvalObject <- (let x : EvalObject <- ((new Closure0).init(new Closure)),
<      y : EvalObject <- (let x : EvalObject <- ((new Closure1).init(new Closure)),
<      y : EvalObject <- ((new Closure2).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- ((new Closure3).init(new Closure)),
<      y : EvalObject <- (let x : EvalObject <- ((new Closure4).init(new Closure)),
<      y : EvalObject <- ((new Closure5).init(new Closure)) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac)
< };
< };
< class Closure5 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 5\n");
<       x <- y;
< ((new Closure6).init(self));}};
< };
< class Closure6 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 6\n");
<       x <- y;
< ((new Closure7).init(self));}};
< };
< class Closure7 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 7\n");
<       x <- y;
< (let x : EvalObject <- (let x : EvalObject <- get_parent().get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac);}};
< };
< class Closure4 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 4\n");
<       x <- y;
< ((new Closure8).init(self));}};
< };
< class Closure8 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 8\n");
<       x <- y;
< ((new Closure9).init(self));}};
< };
< class Closure9 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 9\n");
<       x <- y;
< (let x : EvalObject <- (let x : EvalObject <- get_parent().get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac);}};
< };
< class Closure3 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 3\n");
<       x <- y;
< ((new Closure10).init(self));}};
< };
< class Closure10 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 10\n");
<       x <- y;
< get_parent().get_x();}};
< };
< class Closure2 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 2\n");
<       x <- y;
< ((new Closure11).init(self));}};
< };
< class Closure11 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 11\n");
<       x <- y;
< ((new Closure12).init(self));}};
< };
< class Closure12 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 12\n");
<       x <- y;
< (let x : EvalObject <- (let x : EvalObject <- get_parent().get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac),
<      y : EvalObject <- (let x : EvalObject <- get_parent().get_x(),
<      y : EvalObject <- get_x() in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac) in
<   case x of
<     c : Closure => c.apply(y);
<     o : Object => { abort(); new EvalObject; };
<   esac);}};
< };
< class Closure1 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 1\n");
<       x <- y;
< ((new Closure13).init(self));}};
< };
< class Closure13 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 13\n");
<       x <- y;
< get_parent().get_x();}};
< };
< class Closure0 inherits Closure {
<   apply(y : EvalObject) : EvalObject {
<     { out_string("Applying closure 0\n");
<       x <- y;
< get_x();}};
< };
< ------------------cut here------------------
< COOL program successfully executed
---
> The following symbols are undefined:
> Variable.gen_code
> Main.closure_class
> VarListNE.tail
> Lambda.apply
> LambdaListNE.init
> Variable.print_self
> Term.app
> Lambda.init
> VarListNE.head
> App.substitute
> LambdaListRef.removeHead
> Main.gen_code
> Main.main
> Expr.print_self
> Variable.beta
> LambdaList.headC
> LambdaList.headE
> LambdaList.headN
> App.gen_code
> Term.var
> Variable.substitute
> LambdaListNE.headC
> LambdaListNE.headE
> LambdaListNE.headN
> VarList.print
> Main.beta_reduce
> Lambda.print_self
> LambdaListNE.tail
> App.beta
> LambdaList.isNil
> VarListNE.init
> Expr.substitute
> Variable.init
> Term.lam
> VarListNE.isNil
> LambdaListNE.isNil
> Lambda.gen_closure_code
> Lambda.gen_code
> Expr.gen_code
> LambdaListRef.reset
> LambdaList.tail
> LambdaListRef.headC
> LambdaListRef.headE
> LambdaListRef.headN
> Expr.beta
> Main.eval_class
> App.init
> Lambda.substitute
> LambdaList.add
> VarListNE.print
> Lambda.beta
> App.print_self
> Term.i
> Term.k
> Term.s
> LambdaListRef.add
> LambdaListRef.isNil
> Instruction references undefined symbol at 0x00400038
> [0x00400038]	0x0c000000  jal 0x00000000 [Main.main]      ; 373: jal	Main.main		# Invoke main method
